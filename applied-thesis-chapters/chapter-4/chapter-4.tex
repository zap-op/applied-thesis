\chapter{CÀI ĐẶT GIẢI PHÁP}

\tab Trong chương này, để trình bày cài đặt các giải pháp được dễ hiểu và ngắn gọn hơn.
Nhóm trình bày dựa trên các thông tin cung cấp ở các mục sau:

\begin{itemize}
  \item RTK Query ở mục \textit{\ref{sec:RTKQ} \nameref{sec:RTKQ}}: Cung cấp cái nhìn tổng quan về thư viện và mô tả chức năng.
        Thư viện là một trong những phần cốt lõi để cài đặt ứng dụng web.
  \item RxJS ở mục \textit{\ref{sec:RxJS} \nameref{sec:RxJS}}: Cung cấp cái nhìn tổng quan về thư viện và mô tả chức năng tương tự cách trình bày RTK Query.
        Thư viện là một trong những phần cốt lõi để cài đặt ứng dụng hệ thống.
  \item OWASP Zed Attack Proxy ở mục \textit{\ref{sec:ZAP} \nameref{sec:ZAP}}: Mô tả chi tiết thông tin và chức năng của ứng dụng OWASP Zed Attack Proxy.
        Là thành phần có thông tin chủ chốt để trình bày ở chương này.
\end{itemize}

Các cài đặt có liên quan hay sử dụng bất kỳ thành phần nào trong các mục trên sẽ được nhắc đến một cách lướt qua, không mô tả lại.

Từ đây, nhóm sẽ gọi ứng dụng Node.js ở phía hệ thống là ứng dụng back end, và ứng dụng web sử dụng React dành cho khách là ứng dụng front end.

\section{Cài đặt ứng dụng back end} \label{sec:CaiDatUngDungBackEnd}

\tab Như đã trình bày ở mục \textit{\ref{subsubsec:ThietKeKienTrucTangUngDung} \nameref{subsubsec:ThietKeKienTrucTangUngDung}}, back end bao gồm nhiều service được cài đặt tách biệt với nhau và có các tác dụng khác nhau.
Trong phần này, nhóm sẽ trình bày chi tiết hơn về cách thiết kế của các service này.

\subsection{Cài đặt nhóm ZAP service} \label{subsec:CaiDatNhomZapService}

\tab Như đã mô tả ở phần "Nhóm ZAP service" của mục \textit{\ref{subsubsec:ThietKeKienTrucTangUngDung} \nameref{subsubsec:ThietKeKienTrucTangUngDung}}, cài đặt nhóm ZAP service cũng là một trong những phần khó nhất trong việc xây dựng ứng dụng back end.
Tuy OWASP ZAP là một công cụ được phát triển bởi tổ chức lớn và các lập trình viên kỳ cựu, nhưng quy mô của công cụ là lớn và thời lượng các thành viên hoạt động trên nó còn hạn chế.
Điều này dẫn đến việc các tính năng của công cụ được phát triển tốt.
Nhưng nguồn tài liệu đi kèm còn thiếu, không rõ ràng hoặc chưa có.
Nguồn tài liệu chính thức thực sự hạn chế về số lượng lẫn chất lượng.

Để có thể cài đặt các service tương tác tốt với ứng dụng ZAP,
nhóm cần hiểu được cách hoạt động của những chức năng mà nhóm cần tương tác trong ZAP.
Để thực hiện điều này, nhóm tiến hành các việc như nghiên cứu các tài liệu, thông tin liên quan bên ngoài nguồn chính thống;
Sử dụng thử ứng dụng và các endpoint; Đọc mã nguồn của chính công cụ ZAP.
Chi tiết của các cài đặt được nhóm trình bày trong các phần sau.

\subsubsection{Cài đặt ZAP Client service} \label{subsubsec:CaiDatZapClientService}

\tab Phần cốt lõi của service được thiết kế dựa trên gói zaproxy, gói là một nhánh nhỏ của dự án ứng dụng OWASP Zed Attack Proxy hỗ trợ ứng dụng Node.js tương tác với ứng dụng ZAP dễ dàng hơn. Để liên kết một ZAP instance, nhóm cài đặt phương thức initZapClient() làm xương sống cho service, phương thức trả về đối tượng được tạo từ lớp ZapClient trong gói zaproxy.

Để tạo mới một đối tượng với lớp ZapClient, cần cung cấp hay thuộc tính là apiKey và proxy. Giá trị apiKey là chuỗi tùy chọn, là khóa được sử dụng để xác thực khi sử dụng API với ZAP instance đó. Giá trị proxy là địa chỉ máy chủ ZAP mà ZapClient hướng tới.

Các đối tượng ZapClient sẽ được quản lý trong ZAP Client service dưới dạng cặp client id và ZapClient trong một đối tượng Map() của JavaScript. Client id là một chuỗi định danh duy nhất toàn cầu (Universally Unique Identifier, gọi tắt là UUID) được tạo ngẫu nhiên, dùng để định danh đối tượng ZapClient trong Map. Tuy nhiên, ZAP cũng có cung cấp khá nhiều API mà gói zaproxy chưa có cấu hình, hỗ trợ nên nhóm cũng tiến hành tự tạo các API còn thiếu đó, nếu cần. Nhóm thực hiện điều này thông qua phương thức requestPromise() từ lớp ZapClient với tham số là endpoint của API.

Với mỗi loại quét mà hệ thống hỗ trợ, nhóm thiết kế các phương thức như bắt đầu quét (start), dừng quét (stop), phát trạng thái quét (stream status) và lấy kết quả quét chi tiết (full result) tương ứng với loại quét đó để tương tác với phiên quét trong ZAP instance, phục vụ cho ZAP Monitor service. Do các loại quét, giải pháp khác nhau sẽ có hành vi, cách hoạt động khác nhau nên thiết kế cũng sẽ khác nhau.
\par

Đối với các phương thức start scan, mỗi loại sẽ có các cấu hình, cách thức, thiết kế khác nhau. Nói chung, các phương thức đều cần các tham số như clientId (client id, để xác định đối tượng ZapClient), url (URL hay mục tiêu quét) và config (cấu hình của phiên quét) để bắt đầu phương quét. Thông tin chi tiết về sự khác nhau của các phương thức như sau:
\par

\begin{itemize}
  \item Đối với ZAP Spider, nhóm tạo phương thức spiderStart() trong service để xử lý tác vụ này.
        Phương thức có tham số clientId được xử lý đặc biệt.
        Nếu tham số clientId được chỉ định rõ ràng thì phiên quét sẽ được start trên chính ZAP Client đó.
        Nếu tham số clientId không được chỉ định rõ ràng thì phiên quét sẽ được start trên ZAP Client Shared.
        Khi đó phương thức sẽ trả về một đối tượng có chứa thứ tự của phiên quét trong ZAP instance (gọi là scan id, tên thuộc tính là scanId).
        Nếu tham số config không được chỉ định thì phương thức sẽ sử dụng cấu hình mặc định trong ZAP instance.
        Cấu hình chi tiết cho phiên quét của ZAP Spider được mô tả trong bảng \textit{\ref{tab:ConfigSpider} \nameref{tab:ConfigSpider}} ở dưới.

        \newpage
        \begin{tabularx}{\textwidth}{|>{\hsize=.15\hsize\centering\let\newline
          \\\arraybackslash}X|>{\hsize=.15\hsize\centering\let\newline
          \\\arraybackslash}X|>{\hsize=.50\hsize\raggedright\let\newline
          \\\arraybackslash}X|}
          \hline
          \thead{Tên tham số}
           & \thead{Giá trị \\ mặc định}
           & \thead{Mô tả}
          \\
          \hline
          maxChildren
           &
          0
           &
          Tham số sử dụng để giới hạn số lượng URL con được tìm kiếm tại mỗi nút trong cây tìm kiếm. Tham số bằng 0 thể hiện số nút tìm kiếm là không giới hạn.
          \\
          \hline
          recurse
           &
          true
           &
          Tham số chỉ định cách thức tìm kiếm liên kết. Nếu giá trị là "true", Spider sẽ tìm kiếm các liên kết trên các trang con của trang web hiện tại. Nếu giá trị là "false", Spider chỉ tìm kiếm các liên kết trên trang web hiện tại mà không tìm kiếm các trang con.
          \\
          \hline
          contextName
           &
          ““
           &
          Tham số chỉ định tên của bối cảnh (context). Context là một cấu hình bao gồm các quy tắc như bao gồm (include) hoặc loại trừ (exclude) các URL có liên quan đến URL có trong quy tắc. Các cấu được lưu sẵn với tên, gọi là contextName. Đặt giá trị contextName là tên context đã lưu sẵn để sử dụng cấu hình.
          \\
          \hline
          subtreeOnly
           &
          true
           &
          Tham số chỉ định các thức truy cập các tài nguyên nằm dưới điểm bắt đầu. Nếu giá trị là “true“, Spider sẽ chỉ tìm kiếm các liên kết và trang web con của trang web bắt đầu.
          \\
          \hline
          \caption{Cấu hình phương thức quét ZAP Spider}
          \label{tab:ConfigSpider}
        \end{tabularx}

  \item Đối với ZAP Ajax, nhóm tạo phương thức ajaxStart() trong service để xử lý tác vụ này. Mỗi phiên quét của loại quét này chỉ có thể chạy trong mỗi ZAP instance tại một thời điểm. Nên mỗi khi start phiên quét, nhóm tạo mới một ZAP instance mới và start phiên quét trên instance đó. Ngoài ra, loại quét này còn cần quyền sử dụng trình duyệt (browser) để thực hiện các cuộc tấn công. Vì vậy, nhóm thực hiện cài đặt Firefox browser trong máy chứa ứng dụng back end và cấu hình cho phiên quét sử dụng firefox-headless (tính năng của trình duyệt Firefox, cho phép chạy trình duyệt dưới nền) trong phương thức ajaxStart().
        
  Để đảm bảo tài nguyên của phiên quét loại ZAP Ajax được kiểm soát tốt, nhóm đặt các cấu hình mặc định, không bao gồm trong tham số config, trên ZAP instance trước khi start phiên quét. Các cấu hình như sau:
        \begin{itemize}
          \item Số lượng browser chạy cùng lúc là 1, qua phương thức \\
                ajaxSpider.setOptionNumberOfBrowsers() từ ZAP Client.
          \item Độ sâu tối đa mà trình crawler có thể đạt là 5, qua phương thức \\
                ajaxSpider.setOptionMaxCrawlDepth() từ ZAP Client. Mặc định của ZAP instance là 10.
          \item Thời gian mà trình crawler có thể chạy là 5 phút, qua phương thức \\
                ajaxSpider.setOptionMaxDuration() từ ZAP Client. Mặc định của ZAP instance là 60 phút.
        \end{itemize}
        Nếu tham số config không được chỉ định thì phương thức sẽ sử dụng cấu hình mặc định trong ZAP instance.
        Cấu hình chi tiết cho phiên quét của ZAP Ajax được mô tả trong bảng \textit{\ref{tab:ConfigAjax} \nameref{tab:ConfigAjax}} ở dưới.

        \begin{tabularx}{\textwidth}{|>{\hsize=.15\hsize\centering\let\newline
          \\\arraybackslash}X|>{\hsize=.15\hsize\centering\let\newline
          \\\arraybackslash}X|>{\hsize=.50\hsize\raggedright\let\newline
          \\\arraybackslash}X|}
          \hline
          \thead{Tên tham số}
           & \thead{Giá trị \\ mặc định}
           & \thead{Mô tả}
          \\
          \hline
          inScope
           &
          false
           &
          Nếu tham số có giá trị là “true” thì mọi URL nằm ngoài phạm vi sẽ bị bỏ qua.
          \\
          \hline
          contextName
           &
          ““
           &
          Tham số chỉ định tên của bối cảnh hoạt động. Chi tiết giống với bảng x ở trên.
          \\
          \hline
          subtreeOnly
           &
          true
           &
          Tham số chỉ định các thức truy cập các tài nguyên nằm dưới điểm bắt đầu. Chi tiết giống với bảng x ở trên.
          \\
          \hline
          \caption{Cấu hình phương thức quét ZAP Ajax}
          \label{tab:ConfigAjax}
        \end{tabularx}
  \item Đối với ZAP Passive, nhóm tạo phương thức passiveStart() trong service để xử lý tác vụ này.
        Loại quét này được thực hiện và kết quả được quản lý trên phạm vi toàn ZAP instance nên không thể chạy song song nhiều phiên quét. Nên giống như ZAP Ajax, nhóm tạo một ZAP instance mới cho mỗi phiên quét.

        Như đã nhắc đến ở mục \textit{\ref{subsec:IntroFunc} \nameref{subsec:IntroFunc}}, ZAP Passive là quét thụ động và cần được bổ trợ bởi ZAP Spider hay ZAP Ajax. Vì vậy phương thức có thêm tham số exploreType. Tham số có 2 giá trị là “spider“ và “ajax“, giúp cho phương thức start biết được sẽ sử dụng ZAP Spider hay ZAP Ajax để khám phá. Khi đó, cấu hình chi tiết cho phiên quét sẽ tùy theo cách khám phá mà là cấu hình chi tiết của ZAP Spider hoặc ZAP Ajax. Phương thức không có tham số config.
  \item Đối với ZAP Active, nhóm tạo phương thức activeStart() trong service để xử lý tác vụ này.
        Loại quét này được thực hiện và kết quả được quản lý trên phạm vi toàn ZAP instance nên không thể chạy song song nhiều phiên quét, giống ZAP Passive.
        Vậy nên nhóm cũng tạo ZAP instance mới cho mỗi phiên quét.

        Như đã nhắc đến ở mục \textit{\ref{subsec:IntroFunc} \nameref{subsec:IntroFunc}}, các mục tiêu để tấn công cần được tìm trước thông qua ZAP Spider hay ZAP Ajax nên phương thức cũng có thêm tham số exploreType và cách xử lý giống với passiveStart().
        Ngoài ra, để đảm bảo tất cả các quy tắc quét trong chức năng Scan Policy đều được áp dụng, trước khi start phiên quét, nhóm kích hoạt tất cả các quy tắc quét Scan Policy qua phương thức ascan.enableAllScanners() từ ZAP Client.
        Nếu tham số config không được chỉ định thì phương thức sẽ sử dụng cấu hình mặc định trong ZAP instance.
        Cấu hình chi tiết cho phiên quét của ZAP Active được mô tả trong bảng \textit{\ref{tab:ConfigActive} \nameref{tab:ConfigActive}} ở dưới.
        \begin{tabularx}{\textwidth}{|>{\hsize=.20\hsize\centering\let\newline
          \\\arraybackslash}X|>{\hsize=.20\hsize\centering\let\newline
          \\\arraybackslash}X|>{\hsize=.40\hsize\raggedright\let\newline
          \\\arraybackslash}X|}
          \hline
          \thead{Tên tham số}
           & \thead{Giá trị \\ mặc định}
           & \thead{Mô tả}
          \\
          \hline
          exploreType
           &
          spider
           &
          Giống với mô tả tham số exploreType được mô tả ở mục trên.
          \\
          \hline
          recurse
           &
          true
           &
          Chi tiết giống với tham số recurse ở bảng cấu hình phương thức quét ZAP Spider.
          \\
          \hline
          inScopeOnly
           &
          false
           &
          Chi tiết giống với tham số inScope ở bảng cấu hình phương thức quét ZAP Ajax.
          \\
          \hline
          scanPolicyName
           &
          ““
           &
          Tham số này cho phép người dùng chỉ định chính sách quét được sử dụng trong quá trình quét. Nếu không có chính sách quét nào được chỉ định, công cụ quét sẽ sử dụng chính sách quét mặc định.
          \\
          \hline
          method
           &
          ““
           &
          Tham số này cho phép người dùng chọn một phương thức cụ thể để thực hiện quét, ví dụ như GET hoặc POST.
          \\
          \hline
          postData
           &
          ““
           &
          Tham số này cho phép người dùng chỉ định dữ liệu đăng được sử dụng trong quá trình quét, nếu phương thức được sử dụng là POST.
          \\
          \hline
          contextId
           &
          ““
           &
          Chi tiết tương tự với tham số contextName ở bảng cấu hình phương thức quét ZAP Spider. Nhưng chỉ số thứ tự của context đó trang danh sách đã lưu.
          \\
          \hline
          \caption{Cấu hình phương thức quét ZAP Active}
          \label{tab:ConfigActive}
        \end{tabularx}
\end{itemize}
Nếu start scan thành công thì các phương thức sẽ trả về đối tượng định danh cho phiên quét, không thành công thì trả về đối tượng không xác định.

Đối với các phương thức stop scan, các loại quét được cấu hình tương tự nhau bằng cách gọi đến phương thức stopZapClient(). Phương thức thực hiện gọi đến phương thức shutdown() từ core ZAP Client để tắt ZAP instance và xóa ZAP Client ra khỏi Map lưu trữ. Phương thức stop của ZAP Spider được cấu hình khác biệt, vì ZAP Spider riêng lẻ được chạy trên ZAP Client Shared nên sẽ được gọi đến phương thức stop() của chính phiên quét đó, sử dụng tham số scan id để xác định phiên quét.
\par

Đối với các phương thức stream status, các loại quét được cấu hình tương tự nhau bằng cách tạo một Observable kiểu timer() với RxJS và gọi đến phương thức status() của phiên quét hoặc ZAP Client đó mỗi 5 giây. Kiểu trạng thái nhận lại của mỗi loại quét sẽ khác nhau về kiểu lẫn giá trị.
\par

Đối với các phương thức lấy full result, các loại quét khác nhau sẽ có cách cài đặt khác nhau, kiểu result trả về từ ZAP khác nhau và kiểu result được lưu trữ khác nhau.

\begin{itemize}
  \item Đối với ZAP Spider, nhóm sử dụng phương thức spider.fullResult() từ ZAP Client để lấy full result của phiên quét.
        Dữ liệu trả về còn thô, khó sử dụng, lưu trữ và truy xuất nên nhóm có thực hiện biến đổi lại như sau, chi tiết cách biến đổi kiểu dữ liệu được thể hiện trong hình \textit{\ref{fig:SpiderTransformData} \nameref{fig:SpiderTransformData}} thể hiện kiểu dữ liệu ZAP Spider full result khi mới trả về từ ZAP instance và sau khi được biến đổi.
        \begin{figure}[H]
          \centering
          \includegraphics[width=\textwidth]{applied-thesis-chapters/chapter-4/Quá trình biến đổi của kiểu dữ liệu ZAP Spider full result.png}
          \caption{Quá trình biến đổi của kiểu dữ liệu ZAP Spider full result}
          \label{fig:SpiderTransformData}
        \end{figure}
  \item Đối với ZAP Ajax nhóm sử dụng phương thức ajaxSpider.fullResult() từ ZAP Client để lấy full result và không cần thực hiện biến đổi lại.
  \item Đối với ZAP Passive và ZAP Active, kết quả quét của 2 loại này là thông tin chi tiết của các lỗ hổng tìm năng gọi là cảnh báo (alert).

        ZAP cung cấp khá nhiều tổ hợp thông tin này, mỗi tổ hợp có kiểu dữ liệu khác nhau.
        Nhóm chọn ra 2 tổ hợp thông tin sau đó dựa vào các cách thay đổi, truy xuất tùy chỉnh để có được đầy đủ thông tin.
        Tổ hợp đầu tiên là các alert, nhóm cài đặt phương thức getClientAlerts() trong service, với tham số truyền vào là client id, để lấy danh sách tất cả các alert mà instance tìm được.
        Phương thức getClientAlerts() sử dụng phương thức core.alerts() từ ZAP Client làm xương sống.

        Tổ hợp tiếp theo là các alert theo rủi ro (risk), gọi là alert by risk, risk là một trường chỉ độ nghiêm trọng của alert.
        Nhóm cài đặt phương thức getClientAlertsByRisk() với tham số truyền vào là client id, hoạt động giống getClientAlerts().
        Nhóm tự tạo một API đến ZAP bằng cách sử dụng endpoint /alert/view/alertsByRisk/ với phương thức requestPromise() từ ZAP Client để hỗ trợ phương thức này.
        Tuy nhiên kết quả trả về khá khó sử dụng nên nhóm có thực hiện biến đổi lại như sau, chi tiết cách biến đổi kiểu dữ liệu được thể hiện trong hình \textit{\ref{fig:ActiveTransformData} \nameref{fig:ActiveTransformData}} thể hiện kiểu dữ liệu alert by risk của ZAP Active và ZAP Passive khi mới trả về từ ZAP instance và sau khi được biến đổi.
        \begin{figure}[H]
          \centering
          \includegraphics[width=\textwidth]{applied-thesis-chapters/chapter-4/Quá trình biến đổi của kiểu dữ liệu ZAP Active và ZAP Passive full result.png}
          \caption{Quá trình biến đổi của kiểu dữ liệu ZAP Active và ZAP Passive full result}
          \label{fig:ActiveTransformData}
        \end{figure}
\end{itemize}

\subsubsection{Cài đặt ZAP Monitor service}

\tab Như đã trình bày ở phần "Nhóm ZAP service" của mục \textit{\ref{subsubsec:ThietKeKienTrucTangUngDung} \nameref{subsubsec:ThietKeKienTrucTangUngDung}}, service đóng vai trò trung gian giữa ứng dụng back end và ZAP Client service.

Ứng dụng back end thực hiện tương tác với phiên quét thông qua ZAP Monitor service.
Các tương tác với phiên quét, giống nhau với mọi loại quét, được nhóm thiết kế trong service này là start và giám sát; chia sẻ trạng thái trực tiếp; ra hiệu dừng quét.
Các phiên quét được quản lý trong service dưới dạng cặp định danh giám sát (monitor id) và đối tượng giám sát phiên quét trong một đối tượng Map() của JavaScript.
Cách thức cài đặt cho các tương tác như sau:

\begin{itemize}
  \item Với tương tác start và giám sát, các loại quét đều có thiết kế, luồng hoạt động tương tự nhau nhưng không giống nhau.
        Nhóm cài đặt các phương thức có tên với tiền tố là tên loại quét và hậu tố là StartAndMonitor để thực hiện tác vụ này, ví dụ ajaxStartAndMonitor(), nhóm sẽ gọi ngắn gọn là StartAndMonitor.

        Luồng hoạt động chung của các StartAndMonitor gồm các bước tuần tự là start phiên quét; tạo đối tượng giám sát phiên quét và thêm đối tượng đó vào Map giám sát.
        Monitor id là băm (hash) của đối tượng chứa client id và scan id nên đảm bảo được tính độc nhất.
        Đối tượng giám sát phiên quét, gọi là status monitor (là connectable() trong RxJS).
        Đối tượng dù để cho phép nhiều kết nối có thể đăng ký (subscribe) vào.
        Status monitor gói stream status observable của phiên quét ở bên trong (stream status observable đã nhắc đến ở mục \textit{\ref{subsubsec:CaiDatZapClientService} \nameref{subsubsec:CaiDatZapClientService}}).

        Status monitor dùng để giám sát, thực hiện các tác vụ khi phiên quét đạt tới status cần xử lý và là observable được đẩy lên làm publisher (hay gọi là đối tượng phát trạng thái, emmiter).
        Các tác vụ tiêu biểu được thực hiện trong status monitor là:
        \begin{itemize}
          \item Chỉ phát status khi có thay đổi so với phiên trước (mặc định).
          \item Lấy full result của phiên quét tương ứng từ ZAP Client service và lưu xuống database qua Database service.
          \item Thực hiện giải phóng các tài nguyên liên quan trong quá trình quét như xóa status monitor khỏi Map giám sát, tắt phiên quét, tắt ZAP instance qua ZAP Client service.
        \end{itemize}

  \item Tương tác chia sẻ trạng thái trực tiếp, đặt tên tương tự StartAndMonitor là SharedStatusStream, dành cho ứng dụng back end đưa status monitor lên làm publisher.
        Publisher gửi status phiên quét cho subscriber từ ứng dụng front end bằng SSE, như thiết kế ở hình \textit{\ref{fig:TTZapMonitorStartScan} \nameref{fig:TTZapMonitorStartScan}} ở phần "ZAP Pool" của mục \textit{\ref{subsubsec:ThietKeKienTrucTangUngDung} \nameref{subsubsec:ThietKeKienTrucTangUngDung}}.
  \item Tương tác ra hiệu dừng quét là phương thức thiết kế hỗ trợ cho những trường hợp đặc biệt, được sử dụng như một phương pháp thu gom thủ công trên hệ thống. Những trường hợp này là khi có lỗi không xác định xảy ra, thiết kế dành cho trường hợp đặc biệt. Đảm bảo không có phiên quét dư thừa, ảnh hưởng hiệu suất hệ thống.
\end{itemize}

\subsection{Cài đặt Authentication service}

\tab Nhóm sử dụng nền tảng bên thứ ba là Google Cloud Identity (GCI), một nền tảng quản lý truy cập và nhận diện người dùng, làm chủ chốt để cài đặt service này.
Cụ thể là sử dụng chức năng Xác thực (Authentication) trong nhóm các chức năng “Sign In with Google for Web“ của nền tảng.
Để có thể sử dụng chức năng từ nền tảng, nhóm phải tạo một Google API ID (Google API client ID) để sử dụng trên cả ứng dụng front end và ứng dụng back end.
Cài đặt chi tiết liên quan đến client ID này ở phía ứng dụng front end sẽ được trình bày ở mục \textit{\ref{subsubsec:CaiDatDangKyDangNhap} \nameref{subsubsec:CaiDatDangKyDangNhap}}.
\par

Ở ứng dụng back end, để tương tác được với GCI, nhóm cài đặt gói google-auth-library và sử dụng đối tượng tạo từ lớp OAuth2Client với client ID đã có. Ta sử dụng đối tượng này để kiểm tra lại token credential nằm trong cookie với phương thức verifyIdToken() từ đối tượng, cookie được ghi và gửi kèm đến từ ứng dụng front end. Nếu kết quả kiểm tra là hợp lệ, ta sẽ nhận được một đối tượng chứa thông tin chi tiết của tài khoản người dùng từ GCI trả về, nhóm gọi là GgUserData.
\par

Ngoài sử dụng để xác minh token credential, service được cài đặt và sử dụng chủ yếu làm các middleware ở những API có cần xác thực người dùng.
Các middleware này phối hợp tuần tự với nhau, thực hiện các công việc riêng biệt để bảo vệ API nằm dưới nó.
Hai middleware đầu tiên là parseAccessTokenMdw() và parseRefreshTokenMdw(), sử dụng phương thức expressjwt từ gói express-jwt, dùng để tách và xác minh lại accessToken và refreshToken, ngoài ra còn giúp các API nằm dưới truy cập token đã tách dễ hơn.
Tiếp đó là middleware authenAccessMdw() dùng để kiểm tra tồn tại hợp lệ của accessToken và refreshToken đã tách, thực hiện tạo mới accessToken cho người dùng nếu accessToken đã hết hạn.

Hai cookie trên là 2 JSON Web Token (JWT) token được tạo qua phương thức signJwt() trong service, phương thức được cài đặt bằng cách sử dụng gói jsonwebtoken và khóa riêng tư (private key) của ứng dụng back end là ZAP\_OP\_PRIVATE\_KEY.

\subsection{Cài đặt Database service}

\tab Để service kết nối và tương tác với cơ sở dữ liệu, nhóm sử dụng gói mongoose, một thư viện hỗ trợ tương tác với cơ sở dữ liệu MongoDB dành cho Node.js, để tạo kết nối với MongoDB từ MongoDB Atlas thông qua phương thức connect() được gói cung cấp và chuỗi kết nối đến cơ sở dữ liệu.
\par

Trong MongoDB, một bảng trong database gọi là Collection. Collection được đặt tên theo quy ước của MongoDB và lưu trữ các bản ghi (document) trong đó. Để tương tác với các Collection, ta cần có các đối tượng Model, mỗi Model là đại diện cho mỗi Collection trong Mongoose. Model giúp việc tương tác với MongoDB dễ dàng hơn, không cần viết các câu lệnh trực tiếp để thao tác trên cơ sở dữ liệu. Thay vào đó, ta sử dụng các phương thức có sẵn trong Model để thực hiện các thao tác tương ứng. Đồng thời, định nghĩa cấu trúc (Schema) của Collection cũng có thể được tạo trong lúc tạo Model. Để tạo các Model, ta sử dụng đối tượng đã kết nối với database và phương thức model() được cung cấp bởi thư viện mongoose.
\par

Hệ thống có 4 Model chính dành để lưu trữ dữ liệu cho target, người dùng (user), phiên quét (scan session) và kết quả quét chi tiết (scan full result). Để khởi tạo và định nghĩa các Model này, ứng dụng back end tạo các model có tên tương ứng lần lượt là target.model, user.model, scan-session.model và scan-fullresults.model. Các Model được tạo riêng lẻ trên các tệp khác nhau và xuất đối tượng trả về của model() để chia sẻ cho các tác vụ khác.

Vì hệ thống có nhiều loại document khác nhau trên một Collection, như Collection dành cho phiên quét cần lưu trữ 4 loại phiên quét là ZAP Spider, ZAP Ajax, ZAP Passive và ZAP Active. Nên nhóm cần cấu hình cho các Model để thực hiện tác vụ này.
\par

Mongoose cung cấp một tính năng cho phép định nghĩa các loại document khác nhau trong một Collection là Discriminator. Khi sử dụng Discriminator, có thể định nghĩa một Schema chung cho tất cả các document trong Collection, sau đó định nghĩa các Schema riêng cho các document con. Các Schema riêng này sẽ kế thừa từ Schema chung và bổ sung thêm các định nghĩa của riêng nó. Document của các Schema con sẽ được phân biệt dựa trên một trường phân loại gọi là discriminator key.
\par

Để tạo các Discriminator cho các Collection cần thiết, trên đối tượng Model của Collection đó, nhóm sử dụng phương thức discriminator() cùng một chuỗi dành để phân biệt các Schema con, chuỗi này cũng chính là discriminator key. Các đối tượng trả về từ phương thức discriminator() có thể sử dụng tương tự như đối tượng từ Model, tuy nhiên đối tượng chỉ có ảnh hưởng trên chính các document của chính nó.

\subsection{Cài đặt Logging service}

\tab Service sử dụng gói winston để cài đặt và cấu hình các luồng nhật ký.
Ứng dụng back end có thể cụ thể tạo mới hoặc hủy các log tùy chỉnh qua các phương thức registerCustomLogger() và endCustomLogger().
Các log tùy chỉnh là các loại, đối tượng log mới.
Nằm ngoài 4 loại log chủ yếu được trình bày ở phần "Logging service" của mục \textit{\ref{subsubsec:ThietKeKienTrucTangUngDung} \nameref{subsubsec:ThietKeKienTrucTangUngDung}}.

Các luồng log ngoài hiển thị trên console còn được lưu trữ trong thư mục có tên logs, thư này đồng cấp với thư mục chứa ứng dụng.
Các loại log khác nhau hay mỗi log tùy chỉnh sẽ được lưu trong tệp riêng biệt, với tên tệp (tên luồng log được đặt lúc tạo) và thời gian tương ứng.

\section{Cài đặt chức năng hệ thống} \label{sec:CaiDatChucNangHeThong}

\tab Để thống nhất thông tin chi tiết cho trạng thái của các endpoint giữa ứng dụng front end và ứng dụng back end, nhóm thiết kế 3 bảng trạng thái
\textit{\ref{tab:AuthStatus} \nameref{tab:AuthStatus}}
, \textit{\ref{tab:ScanStatus} \nameref{tab:ScanStatus}}
và \textit{\ref{tab:MgmtStatus} \nameref{tab:MgmtStatus}}
sử dụng riêng cho hệ thống và tùy theo các trường hợp khác nhau.

\begin{tabularx}{\textwidth}{|>{\hsize=.35\hsize\centering\let\newline
  \\\arraybackslash}X|>{\hsize=.60\hsize\raggedright\let\newline
  \\\arraybackslash}X|}
  \hline
  \thead{Tên đại diện}
   & \thead{Đối tượng trạng thái}
  \\
  \hline
  LOGIN\_SUCCESS
   &
  statusCode: 0
  \newlinecontenttable
  msg: "Login successfully"
  \\
  \hline
  REFRESH\_TOKEN
  \newlinecontenttable
  \_SUCCESSFULLY
   &
  statusCode: 1
  \newlinecontenttable
  msg: "Refresh token successfully"
  \\
  \hline
  LOGOUT\_SUCCESS
   &
  statusCode: 2
  \newlinecontenttable
  msg: "Logout successfully"
  \\
  \hline
  TOKEN\_NOT\_FOUND
   &
  statusCode: -1
  \newlinecontenttable
  msg: "No token found"
  \\
  \hline
  TOKEN\_INVALID
   &
  statusCode: -2
  \newlinecontenttable
  msg: "Invalid token"
  \\
  \hline
  USER\_ADD\_FAILED
   &
  statusCode: -3
  \newlinecontenttable
  msg: "New user failed to add"
  \\
  \hline
  USER\_ALREADY\_LINKED
   &
  statusCode: -4
  \newlinecontenttable
  msg: "Google account already used with different email"
  \\
  \hline
  EMAIL\_ALREADY\_USED
   &
  statusCode: -5
  \newlinecontenttable
  msg: "Email already used"
  \\
  \hline
  \caption{Trạng thái cho việc xác thực người dùng (AUTH\_STATUS)}
  \label{tab:AuthStatus}
\end{tabularx}

\begin{tabularx}{\textwidth}{|>{\hsize=.35\hsize\centering\let\newline
  \\\arraybackslash}X|>{\hsize=.60\hsize\raggedright\let\newline
  \\\arraybackslash}X|}
  \hline
  \thead{Tên đại diện}
   & \thead{Đối tượng trạng thái}
  \\
  \hline
  SESSION\_INITIALIZE
  \newlinecontenttable
  \_SUCCEED
   &
  statusCode: 90
  \newlinecontenttable
  msg: "Scan session initialize succeed!"
  \\
  \hline
  SESSION\_INITIALIZE\_FAIL
   &
  statusCode: -91
  \newlinecontenttable
  msg: "Scan session initialize fail!"
  \\
  \hline
  INVAVLID\_URL
   &
  statusCode: -92
  \newlinecontenttable
  msg: "Invalid URL!"
  \\
  \hline
  INVALID\_SESSION
   &
  statusCode: -93
  \newlinecontenttable
  msg: "Invalid scan session!"
  \\
  \hline
  ZAP\_INITIALIZE\_FAIL
   &
  statusCode: -94
  \newlinecontenttable
  msg: "ZAP scan initialize fail!"
  \\
  \hline
  ZAP\_INTERNAL\_ERROR
   &
  statusCode: -95
  \newlinecontenttable
  msg: "ZAP internal error!"
  \\
  \hline
  INVALID\_ID
   &
  statusCode: -96
  \newlinecontenttable
  msg: "Invalid scan id!"
  \\
  \hline
  INVALID\_RESULT\_OFFSET
   &
  statusCode: -97
  \newlinecontenttable
  msg: "Invalid scan result offset!"
  \\
  \hline
  INVALID\_ID\_OR
  \newlinecontenttable
  \_ZAP\_INTERNAL\_ERROR
   &
  statusCode: -98
  \newlinecontenttable
  msg: "Invalid scan id or ZAP internal error!"
  \\
  \hline
  \caption{Trạng thái cho quá trình quét (SCAN\_STATUS)}
  \label{tab:ScanStatus}
\end{tabularx}

\begin{tabularx}{\textwidth}{|>{\hsize=.35\hsize\centering\let\newline
  \\\arraybackslash}X|>{\hsize=.60\hsize\raggedright\let\newline
  \\\arraybackslash}X|}
  \hline
  \thead{Tên đại diện}
   & \thead{Đối tượng trạng thái}
  \\
  \hline
  TARGET\_ADDED
   &
  statusCode: 10
  \newlinecontenttable
  msg: "Target added successfully"
  \\
  \hline
  TARGET\_MOVED
  \newlinecontenttable
  \_TO\_TRASH
   &
  statusCode: 11
  \newlinecontenttable
  msg: "Target moved to trash successfully"
  \\
  \hline
  TARGET\_DELETED
   &
  statusCode: 12
  \newlinecontenttable
  msg: "Target deleted successfully"
  \\
  \hline
  TARGET\_INVAVLID\_URL
   &
  statusCode: -11
  \newlinecontenttable
  msg: "Invalid URL for target"
  \\
  \hline
  TARGET\_ADD\_FAILED
   &
  statusCode: -12
  \newlinecontenttable
  msg: "Target failed to add"
  \\
  \hline
  TARGET\_INVALID\_ID
   &
  statusCode: -13
  \newlinecontenttable
  msg: "Invalid ID for target"
  \\
  \hline
  TARGET\_FIND\_FAILED
   &
  statusCode: -14
  \newlinecontenttable
  msg: "Target failed to find"
  \\
  \hline
  TARGET\_DELETE\_FAILED
   &
  statusCode: -15
  \newlinecontenttable
  msg: "Target failed to delete"
  \\
  \hline
  TARGET\_NAME
  \newlinecontenttable
  \_DUPLICATE
   &
  statusCode: -16
  \newlinecontenttable
  msg: "Target name already exist"
  \\
  \hline
  TARGET\_GET\_FAILED
   &
  statusCode: -17
  \newlinecontenttable
  msg: "Targets cannot be found"
  \\
  \hline
  SESSION\_GET\_FAILED
   &
  statusCode: -18
  \newlinecontenttable
  msg: "Sessions cannot be found"
  \\
  \hline
  \caption{Trạng thái cho các tác vụ quản lý (MGMT\_STATUS)}
  \label{tab:MgmtStatus}
\end{tabularx}

\subsection{Cài đặt các chức năng quản lý phiên đăng nhập}

\subsubsection{Cài đặt chức năng đăng ký / đăng nhập} \label{subsubsec:CaiDatDangKyDangNhap}

\tab Nhóm sử dụng nền tảng Google Cloud Identity, một nền tảng quản lý truy cập và nhận diện người dùng, làm chủ chốt để cài đặt chức năng đăng ký/đăng nhập cho ứng dụng, cụ thể là chức năng “Sign In with Google for Web“, một trong các chức năng Xác thực (Authentication) của nền tảng. Để có thể sử dụng chức năng từ nền tảng, nhóm phải tạo một Google API ID (Google API client ID), sau nhóm sẽ gọi là Google ID.
\par

Ở ứng dụng front end, để sử dụng được Google Sign-In (GSI) nhóm thêm thư viện GSI dành cho phía ứng dụng khách vào bên trong thẻ <head> của tệp HTML chứa ứng dụng, chi tiết như sau:
\par

\lstset{style=mystyle}
\begin{lstlisting}[language=HTML, caption=Thêm thư viện GSI vào ứng dụng]
  <head>
  ...
    <!-- GOOGLE PLATFORM LIBRARY IMPORT -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
  ...
  </head>
\end{lstlisting}

Vì ứng dụng front end được phát triển bằng React TypeScript, nên để sử dụng thư viện một cách tiện lợi nhóm cần phải cài đặt thêm gói @types/google.accounts ở thuộc tính devDependencies trong tệp package.json.

Sau khi đã cài đặt các thư viện nền tảng, nhóm tạo AuthGoogleButton component và thực hiện hóa các chức năng gói trong component này. Component thực hiện cấu hình GSI cho ứng dụng bằng phương thức initialize() từ đối tượng window.google.accounts.id có trong thư viện. Các cấu hình là Google ID và callback là phương thức xử lý thông tin xác thực (credential, là một JSON Web Tokens - JWT) của GSI trả về. Sau đó tiến hành nhúng nút GSI vào ứng dụng bằng phương thức renderButton() từ đối tượng window.google.accounts.id.

Nhóm thiết kế một Mutation endpoint với RTK Query đặt tên là login, endpoint thực hiện request với phương thức HTTP POST đến điểm /auth/login của ứng dụng back end. Endpoint nhận vào biến loại GSI credential và trả về các đối tượng trạng thái như bảng trạng thái cho việc xác thực. Đồng thời, trên hook onQueryStarted của endpoint, nhóm xử lý ghi credential vào cookie tên ggToken tại domain hiện tại. Khi người dùng thực hiện đăng nhập hoàn tất, kích hoạt login endpoint.

Để thực hiện xác thực, ứng dụng back end thực hiện kiểm tra xem người dùng có phải là người dùng mới hay không.
Nếu người dùng là người dùng mới thì thực hiện đăng ký cùng với đăng nhập, nếu không thì thực hiện đăng nhập.
Chi tiết của quá trình được thể hiện trong hình \textit{\ref{fig:SignUpIn} \nameref{fig:SignUpIn}}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{applied-thesis-chapters/chapter-4/Sơ đồ quá trình đăng ký và đăng nhập.png}
  \caption{Sơ đồ quá trình đăng ký và đăng nhập}
  \label{fig:SignUpIn}
\end{figure}

Ở bước “Verify with Google“ trong hình \textit{\ref{fig:SignUpIn} \nameref{fig:SignUpIn}}, ta thực hiện xác thực credential nhận được với Google qua Authentication service.
Ở bước cuối cùng “Response Login Success“ cũng trong hình \textit{\ref{fig:SignUpIn} \nameref{fig:SignUpIn}} sơ đồ luồng kiểm tra đăng nhập, ngoài việc thực hiện trả về các thông tin trong hình ta còn thực hiện ghi 2 cookie là accessToken và refreshToken lên toàn domain của ứng dụng, bao gồm cả tên miền chính và tiên miền con. Hai token này là 2 JWT được tạo qua phương thức signJwt() của Authentication service.

Để ứng dụng front end có được các thông tin cơ bản của người dùng như email, tên, user id và một số thông tin khác khi người dùng hoàn tất đăng ký / đăng nhập.
Ở ứng dụng back end, nhóm cài đặt đóng gói các thông tin cần thiết đó vào trong accessToken lúc thực hiện tác vụ này.
Ở ứng dụng front end, nhóm thực hiện cài đặt một extraReducer trong với Redux Toolkit để lắng nghe trạng thái của login endpoint.
Nếu trạng thái là hoàn thành (matchFulfilled) thì sẽ thực hiện lấy và tách các thông tin cần từ JWT token là accessToken.

Trong việc ghi cookie lên toàn domain của ứng dụng, có một vấn đề đó là nếu đang trong phiên bản phát triển, khi ứng dụng front end chạy trên localhost hay 127.0.0.1 thì không nên thêm thuộc tính domain, việc chỉ định thuộc tính domain trong trường hợp này sẽ gây ra lỗi khiến cho không ghi được cookie. Lỗi này nằm ở thiết kết của cookie của HTTP. Chi tiết như sau:

\textit{“Chỉ các máy chủ trong domain được chỉ định mới có thể đặt cookie cho domain và các domain phải có ít nhất 2 hoặc 3 dấu chấm để ngăn các miền có dạng: ".com", ".edu" và " va.us"…“} \cite{chap4bib4}

Để xử lý vấn đề này nhóm thực hiện như sau, ở phần scripts trong tệp package.json trong ứng dụng Node.js của back end.
Nhóm cài đặt đặt biến môi trường NODE\_ENV là "production" ở lệnh start và NODE\_ENV là "development" ở lệnh dev.
Để việc đặt giá trị cho biến môi trường, để có thể tương thích trên mọi môi trường (hệ điều hành) chạy Node.js thì nhóm sử dụng gói cross-env để cài đặt, hỗ trợ thực hiện tác vụ này. Sau đó nhóm cài đặt phương thức isOnProduction() để kiểm tra giá trị biến môi trường xem ứng dụng backend đang chạy trong chế độ (mode) nào. Và trước khi tiến hành ghi cookie sẽ tiến hành kiểm tra xem ứng dụng backend đang ở mode nào, nếu đang trong development mode thì sẽ không chỉ định thuộc tính domain và ngược lại.

\subsubsection{Cài đặt chức năng làm mới token và đăng xuất}

\tab Để chủ động gia hạn hay làm mới token từ ứng dụng phía front end.
Ở ứng dụng front end, nhóm tạo Mutation endpoint tên refreshCredentials thực hiện request đến điểm /auth/refreshToken của ứng dụng phía back end, bằng phương thức HTTP POST.
Trạng thái matchFulfilled của endpoint này được sử dụng chung cài đặt extraReducer với login endpoint, đã mô tả ở mục \textit{\ref{subsubsec:CaiDatDangKyDangNhap} \nameref{subsubsec:CaiDatDangKyDangNhap}}.
Ở endpoint này của ứng dụng phía back end, cài đặt chỉ bao gồm 3 middleware được sắp xếp theo thứ tự là parseAccessTokenMdw(), parseRefreshTokenMdw() và authenAccessMdw().
Nếu request của ứng dụng phía front end qua được cả ba middleware có nghĩa là tình trạng của accessToken và refreshToken đều hợp lệ.
Tiếp đó thực hiện gia hạn hay tạo mới accessToken và trả về đối tượng trạng thái REFRESH\_TOKEN\_SUCCESSFULLY với HTTP 200.

Để thực hiện đăng xuất cho người dùng.
Ở ứng dụng phía front end, nhóm tạo Mutation endpoint tên logout thực hiện request đến điểm /auth/logout với phương thức HTTP POST.
Đồng thời, thực hiện đặt lại dữ liệu thông tin người dùng ở extraReducer cho trạng thái matchFulfilled của endpoint trên.
Ở ứng dụng phía back end, để kiểm tra trạng thái của người dùng là đang đăng nhập thì endpoint cũng được đặt dưới 3 middleware parseAccessTokenMdw(), parseRefreshTokenMdw() và authenAccessMdw().
Nếu hợp lệ thì thực hiện đăng xuất cho người dùng bằng cách xóa dữ liệu 2 cookie accessToken và refreshToken, qua phương thức clearCookie() được cung cấp thông qua đối tượng trong framework Express.js.
Trả về đối tượng trạng thái LOGOUT\_SUCCESS với HTTP 200.

\subsection{Cài đặt chức năng dùng thử quét với ZAP Spider} \label{subsec:CaiDatDungThuZapSpider}

\tab Ở ứng dụng front end, nhóm tạo một query endpoint với RTK Query đặt tên là trialScan thuộc loại Query endpoint.
Đây là một endpoint tùy chỉnh (custom endpoint) để có thể sử dụng SSE, streaming update, đã đề cập đến ở phần "Các lifecycle hook và Streaming Update" của mục \textit{\ref{sec:RTKQ} \nameref{sec:RTKQ}}.
Endpoint nhận vào tham số target kiểu chuỗi (string) và trả về data custom được mô tả trong bảng \textit{\ref{tab:DesDataTrial} \nameref{tab:DesDataTrial}}.

\begin{tabularx}{\textwidth}{|>{\hsize=.15\hsize\centering\let\newline
  \\\arraybackslash}X|>{\hsize=.15\hsize\centering\let\newline
  \\\arraybackslash}X|>{\hsize=.60\hsize\raggedright\let\newline
  \\\arraybackslash}X|}
  \hline
  \thead{Tên              \\thuộc tính}
   & \thead{Kiểu dữ liệu}
   & \thead{Mô tả}
  \\
  \hline
  isScanning
   &
  boolean
   &
  Thuộc tính cho biết endpoint đang trong quá trình quét hay không
  \\
  \hline
  progress
   &
  number
   &
  Thuộc tính cho biết tiến triển phần trăm của quá trình quét
  \\
  \hline
  data
   &
  string[]
   &
  Thuộc tính lưu trữ các In Scope URL mà ZAP Spider quét được
  \\
  \hline
  error
   &
  Status
   &
  Thuộc tính lưu trữ trạng thái lỗi nếu có lỗi phát sinh trong quá trình quét
  \\
  \hline
  \caption{Mô tả các thuộc tính của đối tượng data custom trong trialScan endpoint}
  \label{tab:DesDataTrial}
\end{tabularx}

Để thể hiện quá trình quét đang được thực hiện, trong hook onQueryStarted của trialScan endpoint ta dùng updateCachedData để cập nhật isScanning thành true. Tiếp đến, ta tiến hành thiết lập kết nối SSE với ứng dụng back end trong hook onCacheEntryAdded. Khi trialScan endpoint được gọi, quá trình xử lý ở 2 phía như sau:

Phía ứng dụng front end, ta thiết lập kết nối SSE tới backend bằng cách sử dụng đối tượng EventSource trong JavaScript.
Endpoint được sử dụng để kết nối là /scan/trial?url="URL", với URL là địa chỉ trang web cần quét.
Sau thiết lập thành công, ta tiếp tục tạo lắng nghe sự kiện trên 3 kênh “id”, “status” và “error”.

\begin{itemize}
  \item Kênh “id” dùng để lắng nghe mã số định danh phiên quét (scan id) của phiên quét.
        Nếu sự kiện gửi đến không hợp lệ thì đóng kết nối SSE và cập nhật lại isScanning thành false.
  \item Kênh “status” dùng để lắng nghe trạng thái tiến độ (progress status) của phiên quét và cập nhật lên data.
        Mỗi khi progress được gửi đến, cập nhật progress lên data và thực hiện lần lượt hai việc.
        \begin{itemize}
          \item Thứ nhất là gọi yêu cầu lấy dữ liệu từ endpoint /scan/trial/results?id=scanId bằng phương thức fetch() và cập nhật dữ liệu nhận được lên data, với scanId là scan id lắng nghe được từ kênh “id” và dữ liệu nhận được là chuỗi các URL kết quả quét từ phiên ZAP Spider trong thời điểm đó.
                Kết quả được xử lý lại nhất quán, không trùng lặp.
          \item Thứ hai là kiểm tra điều kiện duy trì kết nối nếu giá trị status là 100 thì đóng kết nối và cập nhật lại isScanning thành false.
          \item Kênh “error“ dùng để lắng nghe các trạng thái lỗi được gửi đến.
        \end{itemize}
        Nếu có bất kỳ trạng thái nào được gửi đến thì cập nhật thông tin lên error trong đối tượng data custom, đóng kết nối SSE và cập nhật isScanning thành false.
\end{itemize}

Phía ứng dụng back end, cài đặt chức năng quét này khác biệt so với các chức năng quét khác.
Ứng dụng back end thực hiện kết nối SSE trước và kiểm tra sự hợp lệ của URL sau, nếu URL không hợp lệ thì gửi trạng thái INVAVLID\_URL lên kênh “error”.

Để kiểm tra sự hợp lệ của URL, ngoài các cài đặt kiểm tra bình thường nhóm có cài đặt phương thức isValidURL() với điều kiện đặc biệt là: Không được bao gồm chuỗi “localhost“ và “127.0.01“; URL phải có giao thức "http" hoặc "https", sử dụng gói validator.

Cuối cùng start phiên quét và thực hiện đăng ký kết nối của ứng dụng front end cho satus monitor tương ứng bằng ZAP Monitor service.
Phiên quét được start với các cấu hình mặc định cài đặt sẵn cho chức năng dùng thử với ZAP Spider.
Các cấu hình được biểu diễn chi tiết trong bảng \textit{\ref{tab:ConfigSpiderDefault} \nameref{tab:ConfigSpiderDefault}}.

\begin{tabularx}{\textwidth}{|>{\hsize=.45\hsize\centering\let\newline
  \\\arraybackslash}X|>{\hsize=.45\hsize\centering\let\newline
  \\\arraybackslash}X|}
  \hline
  \thead{Tên thuộc tính}
   & \thead{Cài đặt thuộc tính}
  \\
  \hline
  maxChildren
   &
  5
  \\
  \hline
  recurse
   &
  true
  \\
  \hline
  contextName
   &
  ""
  \\
  \hline
  subtreeOnly
   &
  false
  \\
  \hline
  \caption{Bảng chi tiết cấu hình mặc định cho chức năng dùng thử với ZAP Spider}
  \label{tab:ConfigSpiderDefault}
\end{tabularx}

\subsection{Cài đặt chức năng quản lý mục tiêu}

\tab Để hiển thị thông tin chi tiết các target ở ứng dụng front end, nhóm cài đặt getTarget endpoint là một Query endpoint, endpoint thực hiện request HTTP GET đến điểm /management/targets để lấy danh sách thông tin các target. Để getTarget endpoint biết được khi nào data đã cũ thì nhóm cung cấp tag TARGET\_TAG cho hook providesTags.

Ở ứng dụng back end, vì các endpoint trong chức năng quản lý mục tiêu là các endpoint cần xác minh người dùng nên sẽ được đặt dưới các middleware xác thực từ Authentication service. Danh sách thông tin được lấy thông qua target.model với định danh người dùng tương ứng, không bị đánh dấu xóa, sắp xếp theo thứ tự giảm dần ở thuộc tính updateAt và gửi đi.

\subsubsection{Cài đặt chức năng tạo và xóa mục tiêu}

\tab Để thêm mới target, ở ứng dụng front end, nhóm cài đặt addTarget endpoint là một Mutation endpoint, endpoint thực hiện request HTTP POST đến /management/target.
Để đánh dấu danh sách target trong cache đã cũ sau khi thêm mới thì nhóm thêm tag TARGET\_TAG, giống với getTarget endpoint, cho hook invalidatesTags trong endpoint.
Ở ứng dụng back end, thực hiện kiểm tra lại target với phương thức isValidURL() (đã nhắc đến ở mục \textit{\ref{subsec:CaiDatDungThuZapSpider} \nameref{subsec:CaiDatDungThuZapSpider}}) và kiểm tra target có bị trùng tên với nhóm các target đã có của người dùng không. Nếu tất cả đều thỏa thì thêm target vào database. Endpoint gửi và nhận về kết quả trạng thái tương ứng trong bảng MGMT\_STATUS.

Để xóa target, ở ứng dụng front end, nhóm cài đặt moveToTrashTarget endpoint loại Mutation endpoint, thực hiện request HTTP DELETE đến /management/target?id=”ID” với ID là id của target.

Để đánh dấu danh sách target trong cache đã cũ sau khi xóa thì nhóm thực hiện tương tự addTarget endpoint, thêm tag TARGET\_TAG vào hook invalidatesTags.

Ở ứng dụng back end, thực hiện xóa target qua các bước: kiểm tra hợp lệ tham số trên query; kiểm tra sự tồn tại của target bằng target id và user id, nếu hợp lệ thì thực hiện cập nhật thuộc tính idDelete của target đó thành true.

\subsubsection{Cài đặt chức năng tìm mục tiêu theo tên}

\tab Để thực hiện chức năng này, nhóm chỉ thực hiện cài đặt ở phía ứng dụng front end. Danh sách các target được nhóm phân biệt theo 2 đối đượng.

\begin{itemize}
  \item listTarget: Là đối tượng danh sách các target có được từ endpoint.
  \item listShowTarget: Là danh sách các target dùng để hiển thị.
\end{itemize}

listShowTarget là một đối tượng được phản chiếu từ listTarget, các thay đổi trên thanh tìm kiếm sẽ thực hiện lọc và thay đổi listShowTarget.

Khi thực hiện tác vụ trên, nhóm gặp vấn đề vì thông tin trong thanh tìm kiếm là thông tin được nhập từ người dùng, nên tác vụ lọc sẽ được thực hiện rất nhiều lần khi thông tin tìm kiếm thay đổi. Đều này gây ra vấn đề hiệu suất và hiển thị. Để giải quyết vấn đề trên nhóm cài đặt custom hook useDebounceEffect(), sử dụng kỹ thuật debounce, để kiểm soát tầng suất thực hiện tác vụ. Sau đó, nhóm thực hiện bao tác vụ tìm kiếm và lọc trong hook này để khi người dùng dừng thay đổi thông tin tìm kiểm trong một khoảng thời gian thì mới thực hiện lọc. Khoảng thời gian nhóm cài đặt là 300 mili giây.

\subsection{Cài đặt chức năng tạo phiên quét}

\tab Để có thể gửi yêu cầu quét của các loại quét cho ứng dụng back end, ở ứng dụng front end, nhóm cài đặt lần lượt các endpoint cho các loại quét với các tên spiderScan, ajaxScan, passiveScan, activeScan. Các endpoint này đều là Mutation endpoint thực hiện request HTTP POST đến lần lượt các điểm /scan/zap/spider, /scan/zap/ajax, /scan/zap/passive, /scan/zap/active. Các endpoint này đều gửi thông tin target cần quét, riêng passiveScan và activeScan thì cần thêm thông tin exploreType.

Để biết được target nào cần quét và sử dụng các loại quét nào, nhóm tạo một đối tượng danh sách các target được chọn trong store gọi là listSelectedTarget và một đối tượng lưu thông tin trạng thái các lựa chọn quét gọi là scanOption. Đối tượng listSelectedTarget là một mảng có các phần tử là đối tượng chứa một số thông tin của target, thông tin tiêu biểu là target id. Đối tượng scanOption là một đối tượng chứa thông tin trạng thái bật tắt của các loại quét. Cùng với đó, nhóm tạo các reducer tương ứng trong store để thực hiện thay đổi, thêm bớt cho các đối tượng này.

Ở giao diện web, theo cách tạo phiên quét bình thường, người dùng phải trải qua 2 bước thiết lập là chọn các target trong danh sách và cấu hình các phiên quét.
Ở đây nhóm sẽ gọi đến các reducer tương ứng để lưu thông tin vào các đối tượng trong store. Cách tiếp cận này giúp nhóm có thể cài đặt hiển thị bền vững thông tin trạng thái của các lựa chọn trong màn hình, có nghĩa nếu đang trong quá trình tạo phiên quét, người dùng có di chuyển khỏi màn hình thì trạng thái của các lựa chọn cũng không mất đi.

Nhờ cách cài đặt này, người dùng có thể sử dụng chức năng này như chức năng tạo nhiều phiên quét cùng lúc.
Để bắt đầu xử lý gọi các phiên quét, nhóm tạo một custom hook tên useDigestTargetsWithOptions().
Hook sẽ được gọi khi người dùng chọn bắt đầu quét sau khi đã thực hiện lựa chọn xong.
Hook gọi đến lần lượt các trạng thái trong scanOption, ở mỗi trạng thái nếu là true thì sẽ duyệt listSelectedTarget và tạo phiên quét tương ứng với id target đó, gọi đến endpoint dùng để quét đã trình bày ở trên.

Sau khi hoàn thành mỗi lần start scan cho phiên quét, để làm mới lại danh sách phiên quét thì nhóm thực hiện đánh dấu cũ cho tag của endpoint lấy danh sách phiên quét (sẽ được trình bày trong mục \textit{\ref{subsec:CaiDatQuanLyPhienQuet} \nameref{subsec:CaiDatQuanLyPhienQuet}}).
Sau khi hoàn thành thì hook gọi đến reducer tương ứng để làm mới listSelectedTarget và scanOption.

Ở ứng dụng back end, vì các endpoint trong này cần xác minh nên sẽ được đặt dưới các middleware xác thực.
Đối với mỗi endpoint tương ứng sẽ thực hiện start các loại scan tương ứng thông qua ZAP Monitor service, ví dụ endpoint để start ajax sẽ gọi ajaxStartAndMonitor().
Quá trình thực hiện start scan tương tự nhau và được thể hiện qua các bước:

\begin{itemize}
  \item Bước 1: Xác minh sự tồn tại của target trong database thông qua target id. Nếu không target không tồn tại thì trả về đối tượng trạng thái TARGET\_FIND\_FAILED với HTTP\ 400.
  \item Bước 2: Lấy URL trong target ra và tiếp tục kiểm tra sự hợp lệ của URL. Nếu không hợp lệ thì trả về đối tượng trạng thái INVALID\_URL với HTTP\ 400.
  \item Bước 3: Tạo mới đối tượng scan session thông qua đối tượng scan-session.model. Với các dữ liệu là thông tin target, người dùng và cấu hình của phiên.
  \item Bước 4: Bắt đầu start và monitor phiên quét thông qua ZAP Monitor service. Ở đây ZAP Monitor service sẽ trả về một đối tượng định danh phiên quét, như đã nhắc ở mục \textit{\ref{subsubsec:CaiDatZapClientService} \nameref{subsubsec:CaiDatZapClientService}}.
  \item Bước 5: Kiểm tra đối tượng định danh phiên quét được trả về ở bước trên. Nếu đối tượng tồn tại thì tiếp tục. Nếu đối tượng không xác định nghĩa là phiên quét start không thành công. Khi đó thực hiện cập nhật trạng thái quét của scan session là FAILED và lưu đối tượng vào database. Bước tiếp theo trả về đối tượng trạng thái ZAP\_INITIALIZE\_FAIL với HTTP\ 500.
\end{itemize}

Ở ứng dụng front end, khi thực hiện chức năng này, nhóm gặp khó khăn vì danh sách phiên quét sẽ hiển thị nhiều mục phiên quét.
Mà mỗi mục tùy theo loại phiên quét mà sử dụng endpoint khác nhau.
Nhưng không thể cài đặt theo cấu trúc điều kiện cho mỗi mục trong trường hợp này, vì endpoint là hook và React không cho phép sử dụng hook trong cấu trúc điều kiện.
Nhóm giải quyết vấn đề này bằng cách tạo từng component cho từng mục khác nhau, với mỗi mục thuộc mỗi loại phiên quét.
Trong component, thực hiện gọi hook endpoint kết nối SSE trên loại component tương ứng.

\subsection{Cài đặt chức năng quản lý phiên quét} \label{subsec:CaiDatQuanLyPhienQuet}

\tab Để có được danh sách các phiên quét (scan session), ở ứng dụng front end nhóm cài đặt getScanSession endpoint là một Query endpoint, endpoint thực hiện request HTTP GET đến điểm /management/scanSessions để lấy danh sách thông tin các scan session. Để getScanSession endpoint biết được khi nào data đã cũ thì nhóm cung cấp tag SCAN\_SESSION\_TAG cho hook providesTags trong endpoint.

Ở ứng dụng back end, vì các endpoint cần xác minh nên được đặt dưới các middleware xác thực. Danh sách được lấy thông qua scan-session.model với định danh người dùng tương ứng, sắp xếp theo thứ tự giảm dần ở thuộc tính updateAt. Vì nhóm cần thêm thông tin của target kèm với thông tin của scan session tương ứng, nên nhóm sử dụng chức năng Population của mongoose (chức năng thay thế đại diện cho \$lookup aggregation của MongoDB). Khi cài đặt Schema cho scan-session.model, nhóm tạo tham chiếu đến id của document target, và khi truy xuất scan session nhóm sử dụng phương thức populate() để kèm theo thông tin của target tương ứng.

\subsubsection{Cài đặt chức năng xem trạng thái phiên quét} \label{subsubsec:CaiDatXemTrangThaiPhienQuet}

\tab Để thể hiện thông tin trạng thái của một phiên quét trong danh sách quét, nhóm thiết lập 2 loại thông tin là:

\begin{itemize}
  \item Thông tin trạng thái (state): Chỉ trạng thái hiện tại của phiên quét và được thể hiện trong dữ liệu của phiên quét đó.
        Có 3 loại state là PROCESSING, SUCCESSFUL và FAILED.
  \item Thông tin trạng thái tiến triển (progess): Chỉ tiến độ của phiên quét khi phiên quét đang trong state PROCESSING, vì vậy chỉ khi state của phiên quét là PROCESSING thì progress mới hiển thị.
        Tùy theo từng loại quét mà progress sẽ thể hiện khác nhau.
\end{itemize}

Để có được thông tin progress của phiên quét, ở ứng dụng front end, nhóm cài đặt lần lượt các endpoint cho các loại phiên quét với các tên streamSpiderScan, streamAjaxScan, streamPassiveScan, streamActiveScan.
Các endpoint đều là Query endpoint và là custom endpoint để streaming update, đã đề cập đến ở phần "Các lifecycle hook và Streaming Update" của mục \textit{\ref{sec:RTKQ} \nameref{sec:RTKQ}}.

Các endpoint này nhận vào tham số để định danh phiên quét tương ứng của nó ở ứng dụng back end và trả về đối tượng data custom.
Đối tượng data custom có các thuộc tính tương như các thuộc tính được mô tả trong bảng \textit{\ref{tab:DesDataTrial} \nameref{tab:DesDataTrial}} của mục \textit{\ref{subsec:CaiDatDungThuZapSpider} \nameref{subsec:CaiDatDungThuZapSpider}}.
Tuy nhiên, đối tượng không có thuộc tính data và thuộc tính progress sẽ có kiểu và giá trị tùy theo loại phiên quét.

Nếu phiên quét thuộc loại ZAP Spider và ZAP Active thì thuộc tính progress sẽ là kiểu số và có giá trị từ 0 đến 100.
Nếu phiên quét thuộc loại ZAP Ajax và ZAP Passive thì thuộc tính progress sẽ là kiểu chuỗi và có giá trị là “running“ hoặc “stopped“.

Các endpoint tiến hành thiết lập kết nối SSE với ứng dụng back end trong hook onCacheEntryAdded bằng EventSource. Các endpoint được sử dụng để kết nối lần lượt tương ứng là \\
/scan/zap/spider?scanSession=”sessionId”\&zapScanId=”zapScanId”, \\
/scan/zap/ajax?scanSession=”sessionId”\&zapClientId=”zapClientId”, \\
/scan/zap/passive?scanSession=”sessionId”\&zapClientId=”zapClientId”, \\
active?scanSession=”sessionId”\&zapClientId=”zapClientId” với sessionId là định danh document của phiên quét, zapScanId và zapClientId chính là thông tin định danh của đối tượng đang thực hiện phiên quét.

Khi endpoint được gọi, endpoint cập nhật isScanning thành true trên hook onQueryStarted trước rồi thực hiện kết nối SSE với ứng dụng back end trong hook onCacheEntryAdded.
Sau khi thiết lập thành công, tạo lắng nghe sự kiện trên 2 kênh “status” và “error”.
\begin{itemize}
  \item Kênh “status” lắng nghe thông tin progress của phiên quét.
        Mỗi khi trạng thái được gửi đến, thực hiện cập nhật progress lên data và kiểm tra điều kiện duy trì kết nối nếu giá trị status là 100 hoặc “stopped“ thì đóng kết nối và cập nhật lại isScanning thành false.
  \item Kênh “error“ dùng để lắng nghe các trạng thái lỗi được gửi đến.
        Nếu trạng thái được gửi đến thì cập nhật thông tin lên error trong đối tượng data custom, đóng kết nối SSE và cập nhật isScanning thành false.
\end{itemize}

Phía ứng dụng back end, quá trình thực hiện kết nối streamming update tương tự nhau trên các endpoint. Quá trình được thực hiện qua các bước:

\begin{itemize}
  \item Bước 1: Kiểm tra scanSession có tồn tại hợp lệ không và có thuộc về đúng user id không. Nếu không thì trả về đối tượng trạng thái INVALID\_SESSION với HTTP 400.
  \item Bước 2: Kiểm tra zapScanId hay zapClientId có tồn tại hợp lệ không. Nếu không thì trả về đối tượng trạng thái INVALID\_ID với HTTP 400.
  \item Bước 3: Thiết lập kết nối SSE.
  \item Bước 4: Lấy status monitor của phiên quét lên làm publisher qua ZAP Monitor service. Thực hiện kết nối publisher vào các kênh tương ứng ở SSE.
\end{itemize}

Ở ứng dụng front end, khi thực hiện chức năng này, nhóm gặp khó khăn vì danh sách phiên quét sẽ hiển thị nhiều mục phiên quét và mỗi mục tùy theo loại phiên quét mà sử dụng endpoint khác nhau. Không cài đặt theo cấu trúc điều kiện cho mỗi mục trong trường hợp này, vì endpoint là hook và React không cho phép sử dụng hook trong cấu trúc điều kiện. Nhóm giải quyết vấn đề này bằng cách tạo từng component cho từng mục khác nhau, với mỗi mục thuộc mỗi loại phiên quét. Thực hiện gọi hook endpoint kết nối SSE trên loại component tương ứng.

\subsubsection{Cài đặt chức năng xem kết quả quét chi tiết} \label{subsubsec:CaiDatChucNangXemKetQuaQuetChiTiet}

\tab Ở ứng dụng front end, khi người dùng chọn vào một mục phiên quét trong danh sách quét được hiển thị, người dùng sẽ được đưa đến màn hình kết quả quét chi tiết của phiên quét.
Mỗi loại phiên quét khác nhau sẽ có cách hiển thị khác nhau.
Xét chung, kết quả quét chi tiết của các loại quét đều có 2 phần là thông tin chi tiết của phiên quét (scan session) và thông tin chi tiết kết quả (full result).

Thông tin chi tiết của scan session được trích xuất từ data cache của endpoint getScanSession.
Để tối ưu số lần gọi endpoint, nếu người dùng di chuyển vào màn hình khi data cache của endpoint getScanSession có tồn tại thì dữ liệu sẽ được trích xuất ở đó.
Nếu data cache của endpoint getScanSession không tồn tại, ví dụ như trường hợp người dùng tải lại trang tại màn hình này, thì sẽ gọi đến endpoint.

Để có được thông tin full result thì ta cần có session id của chính phiên quét đó.
Id này sẽ được lấy từ scan session ở trên.
Để lấy full result, nhóm tạo các endpoint với các loại scan session tương ứng.
Các endpoint này đều là Query endpoint, endpoint thực hiện request HTTP GET đến các điểm \\
spider/fullResults?scanSession=\$\{sessionId\},\\
ajax/fullResults?scanSession=\$\{sessionId\},\\
passive/fullResults?scanSession=\$\{sessionId\},\\
active/fullResults?scanSession=\$\{sessionId\} với sessionId là scan session id ta có.
Tùy vào endpoint của từng loại quét mà kết quả sẽ khác nhau.
Ở ứng dụng back end, endpoint này của các loại quét được thiết kế xác thực, kiểm tra và truy vấn dữ liệu như thường.

Ở ứng dụng front end, cách thể hiện giao diện màn hình kết quả quét chi tiết của các loại quét cũng khác nhau.
Để thể hiện đầy đủ thông tin kết quả quét chi tiết, nhóm thiết kế như sau.
Màn hình của mỗi loại quét đều có hiển thị phần thông tin chi tiết của scan session, cấu trúc mục cấu hình sẽ khác nhau tương ứng với từng loại quét, như được mô tả ở mục \textit{\ref{subsubsec:CaiDatZapClientService} \nameref{subsubsec:CaiDatZapClientService}}.

Phần tiếp theo trong màn hình là thông tin full result, để hiển thị full result của từng loại kết quả, nhóm phân giao diện phần này thành 2 dạng chính.
Hai dạng đó là dạng danh sách bảng các URL và dạng chi tiết cảnh báo (alerts detail).
Ở màn hình kết quả quét chi tiết, các loại ZAP Spider và ZAP Ajax sẽ sử dụng các thành phần dạng danh sách bảng các URL.
Và loại ZAP Passive và ZAP Active sẽ sử dụng các thành phần dạng alerts detail.
Trong một alerts detail sẽ có 3 phần là tóm tắt cảnh báo (alerts summary), thông tin cảnh báo (alerts information) và chi tiết các cảnh báo (alerts detail).

Tương tự như mục \textit{\ref{subsubsec:CaiDatXemTrangThaiPhienQuet} \nameref{subsubsec:CaiDatXemTrangThaiPhienQuet}}, vì React không cho phép sử dụng hook trong cấu trúc điều kiện. Nên nhóm phải cài đặt từng loại thành phần thông tin cho từng loại quét khác nhau. Và màn hình hiển thị thông tin chi tiết sẽ sử dụng các thành phần này tương ứng với nhu cầu.

\subsubsection{Cài đặt chức năng xuất tệp PDF báo cáo kết quả quét chi tiết} \label{subsubsec:CaiDatChucNangXuatTepPDF}

\tab Khi đang trong màn hình hiển thị thông tin kết quả quét chi tiết, người dùng có thể xuất tệp PDF cho thông tin kết quả này.
Mỗi loại quét khác nhau sẽ có cấu trúc tệp PDF khác nhau.
Tệp PDF này là phiên bản đầy đủ nhất, tham chiếu với dữ liệu của scan session và full result mà hệ thống lưu trữ.

Chức năng này được thực hiện bởi ứng dụng front end.
Để tương tác với tệp PDF bằng TypeScript, nhóm sử dụng gói jspdf là một thư viện mã nguồn mở được viết bằng JavaScript, cho phép tạo và xuất các tài liệu PDF trên trình duyệt web.
Tuy nhiên, nhu cầu của nhóm đa phần là tạo bảng nhưng việc tạo bảng thông qua gói sẽ tạo ra rất nhiều công việc nằm ngoài phạm vi của khóa luận.
Để có thể tạo bảng trong tệp PDF, nhóm đã tìm và sử dụng thêm gói jspdf-autotable là một phần mở rộng của gói jspdf.
Gói jspdf-autotable có các tính năng hỗ trợ tạo bảng dữ liệu trong tài liệu PDF từ mảng dữ liệu, định dạng cột và hàng, tùy chỉnh chiều rộng của cột, chèn hình ảnh và các siêu liên kết vào bảng, và tạo các trang PDF có kích thước tùy chỉnh.

Tuy sự hỗ trợ mạnh mẽ từ gói, nhưng về bản chất đây là một tác vụ duyệt và ghi tệp PDF một cách thủ công.
Nên nhóm cần phải thực hiện một khối công việc nhất định cho chức năng này.
Tùy theo từng loại quét mà nội dung của tệp sẽ khác nhau.
Thứ tự xắp xếp cấu trúc thông tin trong tệp tương tự như đã nhắc ở mục \textit{\ref{subsubsec:CaiDatChucNangXemKetQuaQuetChiTiet} \nameref{subsubsec:CaiDatChucNangXemKetQuaQuetChiTiet}}.

Khi thực hiện chức năng này, nhóm gặp phải khó khăn đó là cộng đồng sử dụng tệp PDF trên ứng dụng web tuy lớn, nhưng phát triển không mạnh. Các công cụ hỗ trợ đa dạng nhưng chưa thực sự tốt và phù hợp với nhu cầu của chức năng. Tài liệu của các công cụ còn hạn chế. Để lựa chọn được gói phù hợp để thực hiện chức năng, nhóm thực hiện dùng thử hết các gói đến khi có gói phù hợp. Cuối cùng nhóm đúc kết được kết quả sử dụng kết hợp 2 gói là jspdf và jspdf-autotable để thực hiện chức năng này.